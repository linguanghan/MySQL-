[TOC]

## MySQL整理

### 一、InnoDB存储引擎

存储引擎：主要负责数据的存储和读取，采用可以替换的插件式架构。存储就是将数据存储到磁盘上，读取就是从磁盘加载数据到内存。

#### 1、一条记录的结构（行格式）

现在为止有四种：`Compact`、`Redundant`、`Dynamic`和`Compressed`

##### 1.1、COMPACT行格式

![img](.\pics\1.png)

###### 1.1.1、记录的额外信息

例子的表结构

```sql
mysql> USE xiaohaizi;
Database changed

mysql> CREATE TABLE record_format_demo (
    ->     c1 VARCHAR(10),
    ->     c2 VARCHAR(10) NOT NULL,
    ->     c3 CHAR(10),
    ->     c4 VARCHAR(10)
    -> ) CHARSET=ascii ROW_FORMAT=COMPACT;
Query OK, 0 rows affected (0.03 sec)
```

插入的数据如下：

![image-20210415140447331](.\pics\image-20210415140447331.png)

**1）变长字段长度列表**

对于一些支持变长的数据类型（`varchar(M)、varbinary(M)、TEXT、BOLB`等类型），因为变长字段中存储多少字节的数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。

* 可变长字段存储的是：**值为非NULL的列值的长度**。并且是**逆序存储**的。

  

  ![img](.\pics\2.png)

**2）NULL值列表**

由于表中的某些列可能会存储NULL值，如果把这些NULL值都放到记录的真实数据中存储会很占地方，所以Compact行格式把这些NULL的列统一管理起来，存储到NULL值列表中。

处理过程：

* 首先统计表字段中允许存储NULL的列有哪些
* 如果表中没有允许存储NULL值的列，则NULL值列表也不存在了，否则将每个允许存储NULL的列对应一个二进制位，二进制位按照列的顺序**逆序排序**
  * 二进制位值为1时，代表该列的值为NULL
  * 二进制位值位0时，代表该列的值不为NULL

例子：表中的`c1，c3，c4`为可能为NULL字段，对于第二条记录c3、c4为空值=>该位置二进制位为1。

![img](.\pics\3.png)

结果：

![img](.\pics\4.png)

**3）记录头信息**（固定五个字节）

用于描述记录

![img](.\pics\5.png)

| 名称         | 大小（单位：bit） | 描述                                                         |
| ------------ | ----------------- | ------------------------------------------------------------ |
| 预留位1      | 1                 | 没有使用                                                     |
| 预留位2      | 1                 | 没有使用                                                     |
| delete_mask  | 1                 | 标记该记录是否被删除                                         |
| min_rec_mask | 1                 | B+树的每层非叶子节点中的最小记录都会添加该标记               |
| n_owned      | 4                 | 表示当前记录拥有的记录数                                     |
| heap_no      | 13                | 表示当前记录在记录堆的位置信息                               |
| record_type  | 3                 | 表示当前记录的类型，`0`表示普通记录，`1`表示B+树非叶子节点记录，`2`表示最小记录，`3`表示最大记录 |
| next_record  | 16                | 表示下一条记录的相对位置                                     |

###### 1.1.2、记录的真实数据

对于`record_format_demo`表来说，`记录的真实数据`除了`c1`、`c2`、`c3`、`c4`这几个我们自己定义的列的数据以外，`MySQL`会为每个记录默认的**添加一些列（也称为`隐藏列`）**，具体的列如下

| 列名          | 是否必须 | 占用空间 | 描述                   |
| ------------- | -------- | -------- | ---------------------- |
| `DB_ROW_ID`   | 否       | 6字节    | 行ID，唯一标识一条记录 |
| `DB_TRX_ID`   | 是       | 6字节    | 事务ID                 |
| `DB_ROLL_PTR` | 是       | 7字节    | 回滚指针               |

结果：

![img](.\pics\6.png)

* 注意第1条记录中`c3`列的值，它是`CHAR(10)`类型的，它实际存储的字符串是：`'cc'`，而`ascii`字符集中的字节表示是`'0x6363'`，虽然表示这个字符串只占用了2个字节，但整个`c3`列仍然占用了10个字节的空间，除真实数据以外的8个字节的统统都用空格字符填充，**空格字符在`ascii`字符集的表示就是`0x20`。**

注：如果定义为char(M)，如果字符集为可变长（如utf-8）的话，这样这个定义为char(M)字段也会加到可变字段长度列表中

##### 1.2、记录中的数据太多产生的溢出

记录的真实数据中，会存储部分的值，另一部分存储指向其他页的地址（存储溢出的数据）

![img](.\pics\7.png)

##### 1.3、Dynamic和Compressed行格式

这两种行格式类似于`COMPACT行格式`，只不过在处理行溢出数据时有点儿分歧，它们不会在记录的真实数据处存储字符串的前768个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址。

#### 2、`InnoDB`数据页结构

`InnoDB`管理存储空间的基本单位：一个页大小一般是`16KB`

`InnoDB`的页之间使用双向链表的数据结构，每个页内的记录会按主键值从小到大顺序组成一个**单向链表**

![img](.\pics\9.png)

##### 2.1、数据页结构

![img](.\pics\8.png)

| 名称                     | 中文名             | 占用空间大小 | 简单描述                 |
| ------------------------ | ------------------ | ------------ | ------------------------ |
| File Header              | 文件头部           | 38字节       | 页的一些通用信息         |
| Page Header              | 页面头部           | 56字节       | 数据页专有的一些信息     |
| **`Infimum + Supremum`** | 最小记录和最大记录 | 26字节       | 两个虚拟的行为           |
| **User Records**         | 用户记录           | 不确定       | 实际存储的行记录内容     |
| Free Space               | 空闲空间           | 不确定       | 页中尚未使用的空间       |
| Page Directory           | 页面目录           | 不确定       | 页中的某些记录的相对位置 |
| File Trailer             | 文件尾部           | 8字节        | 校验页是否完整           |

##### 2.2、Page Directory（页目录）=> 页内的记录分组=>页内查找

###### 2.2.1、如何分组（步骤如下）

规定：对于最小记录所在的分组只能有 ***1*** 条记录，最大记录所在的分组拥有的记录条数只能在 ***1~8*** 条之间，剩下的分组中记录的条数范围只能在是 ***4~8*** 条之间。所以分组是按照下边的步骤进行的：

* 初始情况下一个数据页里只有最小记录和最大记录，他们分属于两个分组
* 之后每插入一条记录，都会从页目录中找到比该记录主键值大并且插值最小的槽，最后把该对应的槽对应记录n_owned+1，表示本组内又添加了一条记录，直到改组中的记录数等于8个
* 在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在`页目录`中新增一个`槽`来记录这个新增分组中最大的那条记录的偏移量。

###### 2.2.2、如何查找（二分查找）

**一个数据页中查找指定主键值的记录的过程分为两步**

![img](D:\study\offer\Java\尚硅谷java基础\笔记\MySQL\pics\10.png)

* 通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。
* 通过记录的`next_record`属性遍历该槽所在的组中的各个记录。

### 二、B+树索引

本节用到的表结构

```sql
mysql> CREATE TABLE index_demo(
    ->     c1 INT,
    ->     c2 INT,
    ->     c3 CHAR(1),
    ->     PRIMARY KEY(c1)
    -> ) ROW_FORMAT = Compact;
Query OK, 0 rows affected (0.03 sec)
```

![img](.\pics\11.png)

`InnoDB`中，非叶子节点存储的是，**主键值和下一个页的页号**，叶子节点**用来存每一条记录。**

#### 1、聚簇索引（聚集索引）---索引即数据、数据即索引

定义：数据行的物理顺序与列值（一般是**主键**的那一列）的逻辑顺序相同，叶子节点中存储的是完整的数据行，一个表中只能拥有一个聚集索引。

**为什么一个表中只有一个聚集索引？**

因为聚集索引决定了表的物理排列顺序，一个表只能有一个物理排列顺序，所以一个表只能建一个聚集索引。

#### 2、二级索引（被建立索引的那个列不是主键）

此时：非叶子节点存储的是**该列+主键（严谨）+下一页**的页号，叶子节点存的是**该列+主键**

![img](.\pics\12.png)

**注：二级查找结果只能找到叶子节点中的主键值，然后要根据这个主键值去聚簇索引中再查找一遍完整的用户记录（回表）**

为啥要有回表操作？

因为如果对每一个索引都把记录都存在叶子节点，这样浪费空间。

#### 3、联合索引

可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引

我们对`c2、c3`建立索引如下:

![img](.\pics\13.png)

注：

* 建立联合索引只会建立如上图一样的一颗B+树
* 为`c2、c3`列分别建立索引会分别以`c2`和`c3`的大小排序规则建立索引

#### 4、MyISAM中的索引方案

在InnoDB中索引即数据，也就是聚簇索引的那颗B+树的叶子节点中已经把所有完整的用户记录都包含了

但是在MyISAM中，索引和数据的存储是分开的。

MyISAM叶子节点存的是**索引列+行号**：根据索引找到行号之后，根据行号去找记录（是一个二级索引）。

![img](D:\study\offer\Java\尚硅谷java基础\笔记\MySQL\pics\14.png)

#### 5、建立索引的方式

* 直接在建表的时候建立

```sql
create table demo(
	c1 int,
    c2 int,
    primary key(c1);
    index idx_c1_c2(c1,c2);
)engine=innodb;
```

* 建表后建立

```sql
alter table demo add index idx_c1_c2(c1,c2); 
```

```sql
create index idx_c1_c2 on demo(c1,c2);
```



### 三、MVCC原理

MVCC(Multi-Version Concurrent Control)，就是多版本并发控制。MVCC是一种并发控制的方法。在Mysql的InnoDB引擎中就是指在读已提交(Read COMMITED)和可重复读(REPEATABLE READ)这两种隔离级别下的事务对于SELECT操作会访问版本链中的记录的过程。

#### 1、版本链

对于使用InnoDB存储引擎的表来说，它的聚簇索引记录中包含两个必要的隐藏列。

* `trx_id`：每次一个事务对某条聚簇索引记录进行改动时，都会把事务的事务id赋值给trx_id隐藏列。
* `roll_pointer`：（指向上一个版本的记录）每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到`undo日志`中，然后这个隐藏列相当于一个指针，可以通过它来找到**记录修改前**的信息。

**例子表：**

```sql
mysql> SELECT * FROM hero;
+--------+--------+---------+
| number | name   | country |
+--------+--------+---------+
|      1 | 刘备   | 蜀      |
+--------+--------+---------+
1 row in set (0.07 sec)
```

* 起初数据库插入一条数据（事务id假设为80）

  ![image_1d8oab1ubb7v5f41j2pai21co19.png-22.4kB](D:\study\offer\Java\尚硅谷java基础\笔记\MySQL\pics\1)

* 之后用两个事务id分别为100，200的事务对这条记录进行UPDATE操作

  ![image_1d8obbc861ulkpt3no31gecrho16.png-92.3kB](D:\study\offer\Java\尚硅谷java基础\笔记\MySQL\pics\21.png)

* 每次对记录进行改动都会记录一条undo日志，每条日志也都有一个roll_pointer属性（INSERT操作没有对应的undo日志没有该属性，因为该记录没有更早的版本），可以将这些undo日志都连起来，串成一个链表，如下：

  ![image_1d8po6kgkejilj2g4t3t81evm20.png-81.7kB](D:\study\offer\Java\尚硅谷java基础\笔记\MySQL\pics\22.png)

#### 2、ReadView

----

> 注：
>
> * READ UNCOMMITTED：由于可以读到未提交的事务修改过的记录，所以直接读取记录的最新版本就好了
> * SERIALIZABLE：加锁
> * READ COMMITTED：每次生成一个ReadView
> * REPEATABLE：用第一次的ReadView

----

**ReadView中的四个重要内容：**

* `m_ids`：表示生成`ReadView`时当前系统中活跃的读写事务的事务`id`列表。

* `min_trx_id`：表示正在生成ReadView时当前系统中活跃的读写事务中最小的事务id，也就是`m_ids`中的最小值。

* `max_trx_id`：表示生成ReadView时当前系统中应该分配给下一个事务的id值

  > 注意：max_trx_id并不是m_ids中的最大值，事务id是递增分配的。比方说现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，m_ids就包括1和2，min_trx_id的值就是1，max_trx_id的值就是4。

* `creator_trx_id`：表示生成该ReadView的事务的`事务id`

**判断规则：**

* 如果被访问版本的`trx_id`属性值与ReadView中的`creator_trx_id`值相同，意味着当前事务在访问它自己修改过的记录，所以该版本被当前事务访问
* 如果被访问版本的`trx_id`属性 **<** ReadView中的min_trx_id，表示该版本事务在当前事务生成的ReadView中已经提交，=> 可以访问
* 如果被访问的版本`trx_id`属性在**min_trx_id和max_trx_id之间**，判断是否在m_ids列表中，如果是说明创建ReadView时该版本的事务还是活跃的，不能被访问，否则可以。
* 如果被访问版本`trx_id`属性大于max_trx_id，那说明这个事务是在当前事务生成ReadView之后才开启的，=> 不可以访问

**例子：（★）**

ReadView中主要就是有一个列表来存储我们系统中当前活跃着的读写事务，也就是begin了还未提交的事务。假设当前活跃的事务id分别有100和200

* 如果我们要访问的事务id为50，这个比100小，那意味着在生成这个ReadView前的这个50的这个事务就已经提交了，此时就是这个50的版本是可以访问的
* 如果我们要访问的事务id为100，那刚好就是我们活跃着的事务id，该版本就不能访问
* 如果我们访问的是150，介于100和200直接，由于此时活跃事务里面没有它，说明他已经被提交了，所以该版本可以访问
* 如果是120的话，那就以为着这个要访问的事务是在这个ReadView之后才开启的，所以该版本不能访问

**注：**

Read Commit--**每次读取数据**前都会生成一个ReadView

Repeatable Read--**在第一次读取数据时**生成一个ReadView

### 四、锁

#### 1、InnoDB的表级锁

* 表级别的S锁、X锁

  **注意：**在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的S锁和X锁的。只会在一些特殊情况下，比如系统崩溃恢复过程中用到

  `LOCK TABLE t READ`：InnoDB存储引擎会对表t加表级别的S锁

  `LOCK TABLE t WRITE`：InnoDB存储引擎会对表t加表级别的X锁

* 表级别的IS锁和、IX锁

  当我们在对使用`InnoDB`存储引擎的表的某些记录加`S锁`之前，那就需要先在表级别加一个`IS锁`，

  当我们在对使用`InnoDB`存储引擎的表的某些记录加`X锁`之前，那就需要先在表级别加一个`IX锁`。

* **表级别的AUTO-INC锁（用于自增）**

  系统实现这种自动给`AUTO_INCREMENT`修饰的列递增赋值的原理主要是两个

  * **采用AUTO-INC锁（不确定要插入多少条时使用的）：**也就是在执行插入语句时就在表级别加一个AUTO-INC锁，然后为每条待插入记录的AUTO_INCREMENT修饰的列分配递增的值，在该语句执行结束之后，再把`AUTO-INC`锁释放掉。**这样一个事务在持有`AUTO-INC`锁的过程中，其他事务的插入语句都要被阻塞**，可以保证一个语句中分配的递增值是连续的。
  * 采用一个轻量级锁：为插入语句生成AUTO_INCREMENT修饰的列的值时获取一下这个轻量级锁，然后生成本次插入语句需要用到的AUTO_INCREMENT列的值之后，就把该轻量级锁释放掉，并不需要等到整个插入语句执行完才释放锁。

#### 2、InnoDB的行级锁

##### 2.1、Record Locks（行锁）

* S锁：当一个事务获取到一条记录的S锁之后，其他事务可以继续获取该记录的S锁，但不可以获取X锁
* X锁：当一个事务获取到一条记录的X锁之后，其他事务不可以继续获取记录的S锁和X锁

![image_1d9etchk0136o49c13t81bn81d3m.png-88.1kB](D:\study\offer\Java\尚硅谷java基础\笔记\MySQL\pics\23.png)



##### 2.2、Gap Locks（间隙锁）--解决幻读的问题

MySQL在REPEATABLE READ隔离级别下是可以解决幻读问题的

方案1：MVCC（简单的select操作）

方案2：加锁：间隙锁（next key）

![image_1d9etbrl938j1v2h1mmjh42e0f9.png-85.7kB](D:\study\offer\Java\尚硅谷java基础\笔记\MySQL\pics\24.png)

如图中为`number`值为`8`的记录加了`gap锁`，意味着不允许别的事务在`number`值为`8`的记录前边的`间隙`插入新记录，其实就是`number`列的值`(3, 8)`这个区间的新记录是不允许立即插入的。比方说有另外一个事务再想插入一条`number`值为`4`的新记录，它定位到该条新记录的下一条记录的`number`值为8，而这条记录上又有一个`gap锁`，所以就会阻塞插入操作，直到拥有这个`gap锁`的事务提交了之后，`number`列的值在区间`(3, 8)`中的新记录才可以被插入。

##### 2.3、next-key locks

有时候我们既想锁住某条记录，又想阻止其他事务在该记录前边的间隙插入新记录，就可以使用next-key locks

![image_1d9mo12guolk1amr1bde1ahjgti85.png-98.6kB](D:\study\offer\Java\尚硅谷java基础\笔记\MySQL\pics\25.png)

### 五、redo和undo

##### 3.1、redo：重做日志，用来实现事务的持久性

由两部分组成：一部分是内存中的重做日志、一部分是硬盘上的重做日志

在InnoDB中，在一个事务提交的时候，并不是直接对内存的数据进行落盘，而是先把日志缓冲中的日志写入文件，然后再提交成功。这样保证了即使在断电的情况下，依然可以依靠redo log进行数据的恢复与重做。

* DML操作导致的页面变化，均需要记录Redo日志;
* 在页面修改完成之后，在脏页刷出磁盘之前，写入Redo日志;
* 日志先行（WAL），日志一定比数据页先写回磁盘;
* 聚簇索引/二级索引/Undo页面修改，均需要记录Redo日志;

##### 3.2、undo：实现事务的回滚，MVCC的快照读取

##### 3.3、比较

redo是物理逻辑日志，计算页的物理修改操作

undo是逻辑记录，记录了行的操作内容



### 补、`MySQL`面试题

#### 1、`MyISAM`和`InnoDB`的区别

##### 1.1、区别

* InnoDB支持**事务**；MyISAM不支持**事务**
* InnoDB支持**外键**；MyISAM不支持**外键**
* InnoDB是**聚集索引**，使用B+树作为索引结构，数据和索引是绑在一起的，必须有主键，通过主键索引效率很高，如果是二级索引的话，就必须进行一个回表操作；MyISAM是**非聚集索引**，也是使用B+树作为索引结构，索引和数据文件时分离的，索引保存的是记录的行号，然后根据行号去查找所要的记录。
* InnoDB表必须有一个唯一索引（主键）用户没有指定的话会自己找生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有。
* InnoDB支持**行锁**（操作时只锁住某一行，不对其他行有影响，适合高并发）；MyISAM支持的是**表锁**（即使操作一条记录也会锁住整个表，不适合高并发）

##### 1.2、如何选择

* 是否要支持事务，支持：`InnoDB`；不支持：`MyISAM`
* 高并发：`InnoDB`
* 如果都是读查询：可以选择`MyISAM`；如果既有读也有写：`InnoDB`

#### 2、为什么`INNoDB`要用B+树，而`HashMap`却要用红黑树呢？

* 因为数据库存的数据要比HashMap多的多，一个是在磁盘上存数据，一个是在内存上存数据。如果InnoDB使用红黑树的话，红黑树的高度会过高，这样会造成磁盘的IO次数过于频繁，这样效率就特别低。还有就红黑树有个左旋右旋，对于大数据量的的，也是很耗时的。
* 相反hashMap是在内存中的，如果使用B+数这种数据结构的话，因为存储的数据量不多，B+树中的页内查找是用二分查找的，数据量不大的话跟线性查找没区别。

#### 3、平衡二叉树（AVL)与红黑树（RBT）的对比

先说一下什么时AVL，什么时RBT

* 平衡二叉树要求一个节点的左右子树高度差值不能大于1，红黑树不是这样的完全平衡。
* 查找对比：
  * AVL树查找时间复杂度比RBT好，最坏情况都是O(logN)
  * RBT查找时间复杂度最好为O(logN)，最坏情况下比AVL略差
* 插入删除对比
  * AVL的插入和删除结点很容易造成树结构的不平衡，而RBT的平衡度要求较低。因此在大量数据插入的情况下，RBT需要通过旋转变色操作来重新达到平衡的频度要小于AVL。
  *  当插入一个结点都引起了树的不平衡，AVL和RBT都最多需要2次旋转操作。但删除一个结点引起不平衡后，AVL最多需要**logN** 次旋转操作，而RBT最多**只需要3次**。因此两者插入一个结点的代价差不多，但删除一个结点的代价RBT要低一些。
* 总体性能上看：红黑树的性能要比平衡二叉树好

#### 4、红黑树和B+树的对比

先说一下什么是红黑树，什么是B+树

* 红黑树主要适用于内存中的排序，比如hashMap就使用了红黑树，在大量的数据插入和删除上面，红黑树的效率比B+树高
* B+树的高度一般不过超过三层，所以应用在数据库的存取上面的话，磁盘的IO次数比较少，这样会大大的提高效率。至于为什么不会超过三层，因为就是一个b+树的非叶子节点，不存储数据，而是存的是关键字和，它的数据都存在叶子节点中。就比如我们数据库里面的聚簇索引，如果引擎是InnoDB的话，非叶子节点就是一个页，页的大小默认是16kb，我们可以存16kb的数据，假设我们每个非叶子可以存储1000个数据，叶子节点可以存100个数据，树为3层的话，就是1000\*1000\*100，就是亿级别的数据了。（具体是2千万+）

#### 5、B树和B+树的区别

* B树的每个节点都存储数据，B+树只有叶子节点存储数据，非叶子节点存储关键字以及指向子节点的指针，能容纳更多的节点元素（展开）。
* B+树中查找，无论查找是否成功，每次都是一条从根节点到叶节点的路径，B树查找如果在非叶子节点找到就可以直接返回
* B树的节点种如果有m个关键字，就有m+1个子节点，B+树节点中如果有m个关键字，就有m个子节点。其中B+树的叶子节点还用链表链起来，支持随机查询和顺序查询。

* B树的优点：每个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。

#### 6、索引介绍

* 首先，索引是一种帮助MySQL高效获取数据的数据结构
* 它的底层是用一颗B+树来维护的，非叶子节点不存储数据，叶子节点存储具体的记录，并且这个叶子节点会用链表串起来。
* 在InnoDB下的索引，他的节点都是由一个叫数据页的东西来维护的，这个数据页的大小一般是16kb，然后在一个数据页中页内存储的数据，会按照这个索引列的顺序排序，默认情况下会有两条伪记录一条记录业内数据的最小值，一条记录页内数据的最大值。
* 数据页内的搜索是采用二分搜索的办法来搜索的，具体怎么实现的，就是有一个页目录，页目录里面有槽，每个槽对应着数据页内的每组数据，这个槽是有序的，所以我们可以先在这个槽上进行二分查到，查找到目标组，然后在组内进行顺序查找（组内的记录最多就8条）。
* 一般在开发过程中
  * 频繁作为查询条件的字段应该建立索引
  * 经常增删改的表或者字段不建立索引
  * 尽量使用覆盖索引

#### 7、索引类型

* **单值索引：**一个索引只包含单个列，一个表就可以有多个单列索引
* **唯⼀索引：**索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式
* **主键索引：**设定为主键后数据库会⾃动建⽴索引，`innodb`为聚簇索引
* **复合索引：**一个索引包含多个列

#### 8、索引优化

* 全值匹配

* 遵循最左匹配原则
* 匹配范围的时候要注意放到最后
* 模糊查询的时候百分号放后面
* 不能对索引列进行操作
* !=号要少用
* order By的时候不能asc、desc混用

#### 9、索引失效场景（跟B+树的结构有关系）

* 没有遵循最左前缀原则（举例：a，b，c）：因为在B+树中按a，b，c顺序索引的话，节点里面的排序是先按a排序，如果a相等就按b排序，如果b相等就按c排序。如果我们现在只用b这个索引，在a不同的情况下，b可能是无序，所以无法使用到索引
* 匹配范围值的时候，范围后面的失效
* 在索引列上做计算：
* 模糊匹配的时候，百分号出现在前面
* order By的时候不能asc、desc混用
* 数据基数特别小的时候

#### 10、聚集索引和非聚集索引

**聚集索引：**数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，由于物理排列方式与聚集索引的顺序相同，所以也就只能建立一个聚集索引了。聚集索引的叶子节点存储的是数据的完整记录。如果不创建索引，系统会自动创建一个隐含列作为表的聚集索引。

**非聚集索引：**该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚簇索引。非聚簇索引的叶子节点存的是索引字段和主键字段，此时会有一个回表的操作。根据主键字段在聚簇索引中继续扫描一次。**使用覆盖索引可以避免回表的过程**

#### 11、一条SQL执行速度很慢原因有哪些（怎么排查慢SQL）？

首先定位到那条慢SQL：**查询慢日志**，查看该条SQL的执行时间。

分类：

* 大多数情况下是正常的，只是偶尔会出现很慢的情况
* 在数据量不变的情况下，这条SQL语句一直以来都很慢

第一种：（偶尔）

* 要查询的数据刚好被其他查询占用了，即使被锁住了
* 数据库在刷新脏页：我们往数据库中插入数据的时候，我们直到数据库会在内存中把对应的字段的数据更新了，但是更新之后，这些字段并不会马上持久化到磁盘上去，而是将这些新的记录写入到redo log日记里面，等到空闲的时候再将最新的数据同步到磁盘里面去。此时是会暂停其他操作的。我们刚好在这个时候查询就会导致速度很慢

第二种：（一直）

* 没有建立索引
* SQL语句导致，索引失效？然后展开索引失效的那些。
* 数据库选错索引了（强制走哪条索引）

#### 12、SQL语句优化，怎么查看SQL的执行过程，explain里面的参数

* 首先使用**explain：**

![image-20210416200053728](.\pics\image-20210416200053728.png)

* 看我们的SQL到底有没有走索引，如果没有走我们就可以建立相应索引或者是修改SQL语句
* 优化选择语句的时候要避免索引失效：索引失效的情况（扩展）
* 优化insert语句
  * 主键顺序插入
  * 手动提交事务（插入多行之后再提交）
* 优化order by语句
  * 升序降序要一致
* 优化group by语句：order by null 禁止排序
* 优化嵌套查询：嵌套查询可以改为join
* 优化OR条件，改为union

#### 13、事务的特性（ACID）

1. **原子性（Atomicity）**
   原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 

2. **一致性（Consistency）**
   事务必须使数据库从一个一致性状态变换到另外一个一致性状态。举例来说，假设用户A和用户B两者的钱加起来一共是1000，那么不管A和B之间如何转账、转几次账，事务结束后两个用户的钱相加起来应该还得是1000，这就是事务的一致性。

3. **隔离性（Isolation）**
   事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。

4. **持久性（Durability）**
   持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。

#### 14、事务的并发问题

1. **脏读：** 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还**没有被提交**的字段。之后, 若 **T2 回滚**, T1读取的内容就是临时且无效的。
2. **不可重复读**：对于两个事务T1、T2， 然后 T2 **更新**了该字段。之后, T1再次读取同一个字段, 值就不同了。
3. **幻读**：对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中**插入**了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。

**小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表**

#### 15、MySQL事务隔离级别

![image-20210416202810209](.\pics\image-20210416202810209.png)

| 隔离级别            | 脏读 | 不可重复读 | 幻读 |
| ------------------- | ---- | ---------- | ---- |
| 读未提交            | 是   | 是         | 是   |
| 读已提交            | 否   | 是         | 是   |
| 可重复读(MySQL默认) | 否   | 否         | 是   |
| 串行化              | 否   | 否         | 否   |

#### 16、什么是SQL注入

用户编写一些特殊的SQL语句来实现无账号登录，甚至篡改数据库。比如我们数据库里面有一条

select * from user where id= '1\' or \'1=1' and password = 10;  

JDBC里面有个PrePareStatement可以解决这个SQL注入问题，使用一个预编译，他的具体作用就是将我们刚刚输入的`1' or '1=1`中的‘转为\\'，这样的话我们输入的这个or语句就会被判别成是一个整体的字符串，在这样就有效的防止了SQL注入

MyBatis中的#{}，和${}。其中$号的话是字符串拼接，也是会有SQL注入问题的，#号的话底层也是用PrepareStatement进行预编译，能有效防止SQL注入。

#### 17、一条SQL语句是怎么执行的？

![image-20210416223344790](.\pics\image-20210416223344790.png)

Server层：

* 连接器
  * 建立连接、获取权限、维持和管理连接
  * 连接建立比较复杂，建议使用长连接
  * 定期断开长连接
* 查询缓存
  * 在MySQL8.0版本后移除
  * 不建议使用，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。
* 分析器
  * 词法分析：提取关键字，比如select，提出查询的表，提出字段名，提出查询条件等等
  * 语法分析：主要判断你的输入SQL是否正确，是否符合SQL语法
* 优化器
  * 优化器的作用是它认为的最优方案去执行，比如索引的选择等等。
* 执行器
  * 进行权限验证之后，验证通过的时候，就去调用数据库引擎的接口，返回结果。

#### 18、`InnoDB`为什么用B+树不用B树，为什么不用Hash？

* Hash 索引**仅仅能满足”=”,”IN”和”<=>”查询，不能使用范围查询**。
* Hash 索引无法用来对数据的**排序**操作。
* Hash 索引**不能利用部分索引键查询**。如(a,b,c)的组合索引，查询中只用到了a和b也可以查询的，如果使用hash表，组合索引会将几个字段合并hash，没办法支持部分索引。
* 当数据量很大时，**hash冲突的概率**也会非常大。

#### 19、覆盖索引的应用场景

* 全表count查询优化
* 列查询回表优化
* 分页查询

#### 20、防止幻读的办法

首先解释什么是幻读：有以下两种解决方案

**方法一：**`MVCC`：仅在读提交和可重复读两种隔离级别下生效

讲一下`MVCC`

事务开始的时候创建一个readview, 一直到事务结束都用的这个readview，也就避免了不可重复读

例子举一个：20 【100，200】

**方法二：**间隙锁+行锁

#### 21、为什么`MyISAM`查询比较快

**`INNODB`在做SELECT的时候，要维护的东西比`MYISAM`引擎多很多:**
1）数据块，`INNODB`要缓存，`MYISAM`只缓存索引块， 这中间还有换进换出的减少；

2）`innodb`寻址要映射到块，再到行，`MYISAM`记录的直接是文件的OFFSET，定位比`INNODB`要快

3）`INNODB`还需要维护`MVCC`一致；虽然你的场景没有，但他还是需要去检查和维护`MVCC` (Multi-Version Concurrency Control)多版本并发控制 

#### 22、左连接、右连接、内连接的区别？

**左连接：**左边有的，右边没有的为null

**右连接：**左边没有的，右边有的为null

**内连接：**显示左边右边共有的

#### 23、补充：linux命令统计文件中某个字符串出现的次数？

`grep -c '字符串名称' 文件名`

如果是压缩文件

`zgrep -c '字符串名称' 文件名`

![image-20210425183514017](C:\Users\13540\Desktop\java面试整理\pic\image-20210425183514017.png)

#### 24、数据库的三大范式

##### 24.1、第一范式（确保每列保证原子性）

数据库中的字段值都是不可分解的原子值。

##### 24.2、第二范式（确保表中的每列都和主键相关）

若某关系R属于第一范式，且每一个非主属性完全函数依赖于任何一个候选码，则关系R属于第二范式。

举个例子：通过AB能得出C，通过A也能得出C，通过B也能得出C，那么说C部分依赖于AB。

注意：通过A也能得出C，通过B也能得出C，这两个条件满足其一即可达到部分函数依赖。

##### 24.3、第三范式（在第二范式的基础上消除了传递依赖）

![image-20210426075353110](.\pics\image-20210426075353110.png)

上表的问题：这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关=>违反了第三范式的设计原则

=>拆分成订单表和商品详情表

#### 25、MySQl做了哪些优化？

* 缓存（8.0后被移除）

  在解析一个查询语句之前，如果缓存是打开的，那么`MySQL`会检查这个查询语句是否命中查询缓存中的数据。如果当前恰好命中查询缓存，在检查一次用户权限之后就会直接返回缓存中的结果。这种情况下。查询不会被解析。也不会生成执行计划。

  * `MySQL`将缓存存放在一个引用表，通过一个hash索引，**这个hash值就是查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息计算得来的。**所以两个查询在任何字符上的不同，都会导致缓存不会命中。
  * 如果查询中包含任何用户自定义函数，存储函数、用户变量、临时表、mysql中的系统表=>结果不会被缓存
  * **缓存失效：**`MySQL`的查询缓存系统会跟踪查询中涉及的每个表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。

* 查询优化

  

* 