## MVCC、锁

### 一、MVCC原理

MVCC(Multi-Version Concurrent Control)，就是多版本并发控制。MVCC是一种并发控制的方法。在Mysql的InnoDB引擎中就是指在读已提交(Read COMMITED)和可重复读(REPEATABLE READ)这两种隔离级别下的事务对于SELECT操作会访问版本链中的记录的过程。

#### 1、版本链

对于使用InnoDB存储引擎的表来说，它的聚簇索引记录中包含两个必要的隐藏列。

* `trx_id`：每次一个事务对某条聚簇索引记录进行改动时，都会把事务的事务id赋值给trx_id隐藏列。
* `roll_pointer`：（指向上一个版本的记录）每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到`undo日志`中，然后这个隐藏列相当于一个指针，可以通过它来找到**记录修改前**的信息。

**例子表：**

```sql
mysql> SELECT * FROM hero;
+--------+--------+---------+
| number | name   | country |
+--------+--------+---------+
|      1 | 刘备   | 蜀      |
+--------+--------+---------+
1 row in set (0.07 sec)
```

* 起初数据库插入一条数据（事务id假设为80）

  ![image_1d8oab1ubb7v5f41j2pai21co19.png-22.4kB](.\pics\1)

* 之后用两个事务id分别为100，200的事务对这条记录进行UPDATE操作

  ![image_1d8obbc861ulkpt3no31gecrho16.png-92.3kB](.\pics\21.png)

* 每次对记录进行改动都会记录一条undo日志，每条日志也都有一个roll_pointer属性（INSERT操作没有对应的undo日志没有该属性，因为该记录没有更早的版本），可以将这些undo日志都连起来，串成一个链表，如下：

  ![image_1d8po6kgkejilj2g4t3t81evm20.png-81.7kB](.\pics\22.png)

#### 2、ReadView

----

> 注：
>
> * READ UNCOMMITTED：由于可以读到未提交的事务修改过的记录，所以直接读取记录的最新版本就好了
> * SERIALIZABLE：加锁
> * READ COMMITTED：每次生成一个ReadView
> * REPEATABLE：用第一次的ReadView

----

**ReadView中的四个重要内容：**

* `m_ids`：表示生成`ReadView`时当前系统中活跃的读写事务的事务`id`列表。

* `min_trx_id`：表示正在生成ReadView时当前系统中活跃的读写事务中最小的事务id，也就是`m_ids`中的最小值。

* `max_trx_id`：表示生成ReadView时当前系统中应该分配给下一个事务的id值

  > 注意：max_trx_id并不是m_ids中的最大值，事务id是递增分配的。比方说现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，m_ids就包括1和2，min_trx_id的值就是1，max_trx_id的值就是4。

* `creator_trx_id`：表示生成该ReadView的事务的`事务id`

**判断规则：**

* 如果被访问版本的`trx_id`属性值与ReadView中的`creator_trx_id`值相同，意味着当前事务在访问它自己修改过的记录，所以该版本被当前事务访问
* 如果被访问版本的`trx_id`属性 **<** ReadView中的min_trx_id，表示该版本事务在当前事务生成的ReadView中已经提交，=> 可以访问
* 如果被访问的版本`trx_id`属性在**min_trx_id和max_trx_id之间**，判断是否在m_ids列表中，如果是说明创建ReadView时该版本的事务还是活跃的，不能被访问，否则可以。
* 如果被访问版本`trx_id`属性大于max_trx_id，那说明这个事务是在当前事务生成ReadView之后才开启的，=> 不可以访问

**例子：（★）**

ReadView中主要就是有一个列表来存储我们系统中当前活跃着的读写事务，也就是begin了还未提交的事务。假设当前活跃的事务id分别有100和200

* 如果我们要访问的事务id为50，这个比100小，那意味着在生成这个ReadView前的这个50的这个事务就已经提交了，此时就是这个50的版本是可以访问的
* 如果我们要访问的事务id为100，那刚好就是我们活跃着的事务id，该版本就不能访问
* 如果我们访问的是150，介于100和200直接，由于此时活跃事务里面没有它，说明他已经被提交了，所以该版本可以访问
* 如果是120的话，那就以为着这个要访问的事务是在这个ReadView之后才开启的，所以该版本不能访问

**注：**

Read Commit--**每次读取数据**前都会生成一个ReadView

Repeatable Read--**在第一次读取数据时**生成一个ReadView

### 二、锁

#### 1、InnoDB的表级锁

* 表级别的S锁、X锁

  **注意：**在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的S锁和X锁的。只会在一些特殊情况下，比如系统崩溃恢复过程中用到

  `LOCK TABLE t READ`：InnoDB存储引擎会对表t加表级别的S锁

  `LOCK TABLE t WRITE`：InnoDB存储引擎会对表t加表级别的X锁

* 标记别的IS锁和、IX锁

  当我们在对使用`InnoDB`存储引擎的表的某些记录加`S锁`之前，那就需要先在表级别加一个`IS锁`，

  当我们在对使用`InnoDB`存储引擎的表的某些记录加`X锁`之前，那就需要先在表级别加一个`IX锁`。

* **标记别的AUTO-INC锁（用于自增）**

  系统实现这种自动给`AUTO_INCREMENT`修饰的列递增赋值的原理主要是两个

  * **采用AUTO-INC锁（不确定要插入多少条时使用的）：**也就是在执行插入语句时就在表级别加一个AUTO-INC锁，然后为每条待插入记录的AUTO_INCREMENT修饰的列分配递增的值，在该语句执行结束之后，再把`AUTO-INC`锁释放掉。**这样一个事务在持有`AUTO-INC`锁的过程中，其他事务的插入语句都要被阻塞**，可以保证一个语句中分配的递增值是连续的。
  * 采用一个轻量级锁：为插入语句生成AUTO_INCREMENT修饰的列的值时获取一下这个轻量级锁，然后生成本次插入语句需要用到的AUTO_INCREMENT列的值之后，就把该轻量级锁释放掉，并不需要等到整个插入语句执行完才释放锁。

#### 2、InnoDB的行级锁

##### 2.1、Record Locks（记录锁）

* S锁：当一个事务获取到一条记录的S锁之后，其他事务可以继续获取该记录的S锁，但不可以获取X锁
* X锁：当一个事务获取到一条记录的X锁之后，其他事务不可以继续获取记录的S锁和X锁

![image_1d9etchk0136o49c13t81bn81d3m.png-88.1kB](.\pics\23.png)



##### 2.2、Gap Locks（间隙锁）--解决幻读的问题

MySQL在REPEATABLE READ隔离级别下是可以解决幻读问题的

方案1：MVCC（简单的select操作）

方案2：加锁：间隙锁（next key）

![image_1d9etbrl938j1v2h1mmjh42e0f9.png-85.7kB](.\pics\24.png)

如图中为`number`值为`8`的记录加了`gap锁`，意味着不允许别的事务在`number`值为`8`的记录前边的`间隙`插入新记录，其实就是`number`列的值`(3, 8)`这个区间的新记录是不允许立即插入的。比方说有另外一个事务再想插入一条`number`值为`4`的新记录，它定位到该条新记录的下一条记录的`number`值为8，而这条记录上又有一个`gap锁`，所以就会阻塞插入操作，直到拥有这个`gap锁`的事务提交了之后，`number`列的值在区间`(3, 8)`中的新记录才可以被插入。

##### 2.3、next-key locks

有时候我们既想锁住某条记录，又想阻止其他事务在该记录前边的间隙插入新记录，就可以使用next-key locks

![image_1d9mo12guolk1amr1bde1ahjgti85.png-98.6kB](.\pics\25.png)

### 三、redo和undo

##### 3.1、redo：重做日志，用来实现事务的持久性

由两部分组成：一部分是内存中的重做日志、一部分是硬盘上的重做日志

在InnoDB中，在一个事务提交的时候，并不是直接对内存的数据进行落盘，而是先把日志缓冲中的日志写入文件，然后再提交成功。这样保证了即使在断电的情况下，依然可以依靠redo log进行数据的恢复与重做。

* DML操作导致的页面变化，均需要记录Redo日志;
* 在页面修改完成之后，在脏页刷出磁盘之前，写入Redo日志;
* 日志先行（WAL），日志一定比数据页先写回磁盘;
* 聚簇索引/二级索引/Undo页面修改，均需要记录Redo日志;

##### 3.2、undo：实现事务的回滚，MVCC的快照读取

##### 3.3、比较

redo是物理逻辑日志，计算页的物理修改操作

undo是逻辑记录，记录了行的操作内容

